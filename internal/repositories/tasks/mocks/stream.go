// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	jetstream "github.com/nats-io/nats.go/jetstream"
	mock "github.com/stretchr/testify/mock"

	nats "github.com/nats-io/nats.go"

	time "time"
)

// Stream is an autogenerated mock type for the Stream type
type Stream struct {
	mock.Mock
}

type Stream_Expecter struct {
	mock *mock.Mock
}

func (_m *Stream) EXPECT() *Stream_Expecter {
	return &Stream_Expecter{mock: &_m.Mock}
}

// AccountInfo provides a mock function with given fields: ctx
func (_m *Stream) AccountInfo(ctx context.Context) (*jetstream.AccountInfo, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AccountInfo")
	}

	var r0 *jetstream.AccountInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*jetstream.AccountInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *jetstream.AccountInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.AccountInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_AccountInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountInfo'
type Stream_AccountInfo_Call struct {
	*mock.Call
}

// AccountInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Stream_Expecter) AccountInfo(ctx interface{}) *Stream_AccountInfo_Call {
	return &Stream_AccountInfo_Call{Call: _e.mock.On("AccountInfo", ctx)}
}

func (_c *Stream_AccountInfo_Call) Run(run func(ctx context.Context)) *Stream_AccountInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Stream_AccountInfo_Call) Return(_a0 *jetstream.AccountInfo, _a1 error) *Stream_AccountInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_AccountInfo_Call) RunAndReturn(run func(context.Context) (*jetstream.AccountInfo, error)) *Stream_AccountInfo_Call {
	_c.Call.Return(run)
	return _c
}

// CleanupPublisher provides a mock function with no fields
func (_m *Stream) CleanupPublisher() {
	_m.Called()
}

// Stream_CleanupPublisher_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CleanupPublisher'
type Stream_CleanupPublisher_Call struct {
	*mock.Call
}

// CleanupPublisher is a helper method to define mock.On call
func (_e *Stream_Expecter) CleanupPublisher() *Stream_CleanupPublisher_Call {
	return &Stream_CleanupPublisher_Call{Call: _e.mock.On("CleanupPublisher")}
}

func (_c *Stream_CleanupPublisher_Call) Run(run func()) *Stream_CleanupPublisher_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Stream_CleanupPublisher_Call) Return() *Stream_CleanupPublisher_Call {
	_c.Call.Return()
	return _c
}

func (_c *Stream_CleanupPublisher_Call) RunAndReturn(run func()) *Stream_CleanupPublisher_Call {
	_c.Run(run)
	return _c
}

// Conn provides a mock function with no fields
func (_m *Stream) Conn() *nats.Conn {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Conn")
	}

	var r0 *nats.Conn
	if rf, ok := ret.Get(0).(func() *nats.Conn); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*nats.Conn)
		}
	}

	return r0
}

// Stream_Conn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Conn'
type Stream_Conn_Call struct {
	*mock.Call
}

// Conn is a helper method to define mock.On call
func (_e *Stream_Expecter) Conn() *Stream_Conn_Call {
	return &Stream_Conn_Call{Call: _e.mock.On("Conn")}
}

func (_c *Stream_Conn_Call) Run(run func()) *Stream_Conn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Stream_Conn_Call) Return(_a0 *nats.Conn) *Stream_Conn_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_Conn_Call) RunAndReturn(run func() *nats.Conn) *Stream_Conn_Call {
	_c.Call.Return(run)
	return _c
}

// Consumer provides a mock function with given fields: ctx, stream, consumer
func (_m *Stream) Consumer(ctx context.Context, stream string, consumer string) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, consumer)

	if len(ret) == 0 {
		panic("no return value specified for Consumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, consumer)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, stream, consumer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_Consumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Consumer'
type Stream_Consumer_Call struct {
	*mock.Call
}

// Consumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - consumer string
func (_e *Stream_Expecter) Consumer(ctx interface{}, stream interface{}, consumer interface{}) *Stream_Consumer_Call {
	return &Stream_Consumer_Call{Call: _e.mock.On("Consumer", ctx, stream, consumer)}
}

func (_c *Stream_Consumer_Call) Run(run func(ctx context.Context, stream string, consumer string)) *Stream_Consumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Stream_Consumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *Stream_Consumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_Consumer_Call) RunAndReturn(run func(context.Context, string, string) (jetstream.Consumer, error)) *Stream_Consumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *Stream) CreateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateConsumer'
type Stream_CreateConsumer_Call struct {
	*mock.Call
}

// CreateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *Stream_Expecter) CreateConsumer(ctx interface{}, stream interface{}, cfg interface{}) *Stream_CreateConsumer_Call {
	return &Stream_CreateConsumer_Call{Call: _e.mock.On("CreateConsumer", ctx, stream, cfg)}
}

func (_c *Stream_CreateConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *Stream_CreateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *Stream_CreateConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *Stream_CreateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreateConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)) *Stream_CreateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateKeyValue provides a mock function with given fields: ctx, cfg
func (_m *Stream) CreateKeyValue(ctx context.Context, cfg jetstream.KeyValueConfig) (jetstream.KeyValue, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateKeyValue")
	}

	var r0 jetstream.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) jetstream.KeyValue); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.KeyValueConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreateKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateKeyValue'
type Stream_CreateKeyValue_Call struct {
	*mock.Call
}

// CreateKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.KeyValueConfig
func (_e *Stream_Expecter) CreateKeyValue(ctx interface{}, cfg interface{}) *Stream_CreateKeyValue_Call {
	return &Stream_CreateKeyValue_Call{Call: _e.mock.On("CreateKeyValue", ctx, cfg)}
}

func (_c *Stream_CreateKeyValue_Call) Run(run func(ctx context.Context, cfg jetstream.KeyValueConfig)) *Stream_CreateKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.KeyValueConfig))
	})
	return _c
}

func (_c *Stream_CreateKeyValue_Call) Return(_a0 jetstream.KeyValue, _a1 error) *Stream_CreateKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreateKeyValue_Call) RunAndReturn(run func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)) *Stream_CreateKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// CreateObjectStore provides a mock function with given fields: ctx, cfg
func (_m *Stream) CreateObjectStore(ctx context.Context, cfg jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateObjectStore")
	}

	var r0 jetstream.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) jetstream.ObjectStore); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.ObjectStoreConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreateObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateObjectStore'
type Stream_CreateObjectStore_Call struct {
	*mock.Call
}

// CreateObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.ObjectStoreConfig
func (_e *Stream_Expecter) CreateObjectStore(ctx interface{}, cfg interface{}) *Stream_CreateObjectStore_Call {
	return &Stream_CreateObjectStore_Call{Call: _e.mock.On("CreateObjectStore", ctx, cfg)}
}

func (_c *Stream_CreateObjectStore_Call) Run(run func(ctx context.Context, cfg jetstream.ObjectStoreConfig)) *Stream_CreateObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.ObjectStoreConfig))
	})
	return _c
}

func (_c *Stream_CreateObjectStore_Call) Return(_a0 jetstream.ObjectStore, _a1 error) *Stream_CreateObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreateObjectStore_Call) RunAndReturn(run func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)) *Stream_CreateObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *Stream) CreateOrUpdateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreateOrUpdateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateConsumer'
type Stream_CreateOrUpdateConsumer_Call struct {
	*mock.Call
}

// CreateOrUpdateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *Stream_Expecter) CreateOrUpdateConsumer(ctx interface{}, stream interface{}, cfg interface{}) *Stream_CreateOrUpdateConsumer_Call {
	return &Stream_CreateOrUpdateConsumer_Call{Call: _e.mock.On("CreateOrUpdateConsumer", ctx, stream, cfg)}
}

func (_c *Stream_CreateOrUpdateConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *Stream_CreateOrUpdateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *Stream_CreateOrUpdateConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *Stream_CreateOrUpdateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreateOrUpdateConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)) *Stream_CreateOrUpdateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateKeyValue provides a mock function with given fields: ctx, cfg
func (_m *Stream) CreateOrUpdateKeyValue(ctx context.Context, cfg jetstream.KeyValueConfig) (jetstream.KeyValue, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateKeyValue")
	}

	var r0 jetstream.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) jetstream.KeyValue); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.KeyValueConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreateOrUpdateKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateKeyValue'
type Stream_CreateOrUpdateKeyValue_Call struct {
	*mock.Call
}

// CreateOrUpdateKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.KeyValueConfig
func (_e *Stream_Expecter) CreateOrUpdateKeyValue(ctx interface{}, cfg interface{}) *Stream_CreateOrUpdateKeyValue_Call {
	return &Stream_CreateOrUpdateKeyValue_Call{Call: _e.mock.On("CreateOrUpdateKeyValue", ctx, cfg)}
}

func (_c *Stream_CreateOrUpdateKeyValue_Call) Run(run func(ctx context.Context, cfg jetstream.KeyValueConfig)) *Stream_CreateOrUpdateKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.KeyValueConfig))
	})
	return _c
}

func (_c *Stream_CreateOrUpdateKeyValue_Call) Return(_a0 jetstream.KeyValue, _a1 error) *Stream_CreateOrUpdateKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreateOrUpdateKeyValue_Call) RunAndReturn(run func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)) *Stream_CreateOrUpdateKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateObjectStore provides a mock function with given fields: ctx, cfg
func (_m *Stream) CreateOrUpdateObjectStore(ctx context.Context, cfg jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateObjectStore")
	}

	var r0 jetstream.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) jetstream.ObjectStore); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.ObjectStoreConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreateOrUpdateObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateObjectStore'
type Stream_CreateOrUpdateObjectStore_Call struct {
	*mock.Call
}

// CreateOrUpdateObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.ObjectStoreConfig
func (_e *Stream_Expecter) CreateOrUpdateObjectStore(ctx interface{}, cfg interface{}) *Stream_CreateOrUpdateObjectStore_Call {
	return &Stream_CreateOrUpdateObjectStore_Call{Call: _e.mock.On("CreateOrUpdateObjectStore", ctx, cfg)}
}

func (_c *Stream_CreateOrUpdateObjectStore_Call) Run(run func(ctx context.Context, cfg jetstream.ObjectStoreConfig)) *Stream_CreateOrUpdateObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.ObjectStoreConfig))
	})
	return _c
}

func (_c *Stream_CreateOrUpdateObjectStore_Call) Return(_a0 jetstream.ObjectStore, _a1 error) *Stream_CreateOrUpdateObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreateOrUpdateObjectStore_Call) RunAndReturn(run func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)) *Stream_CreateOrUpdateObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdatePushConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *Stream) CreateOrUpdatePushConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.PushConsumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdatePushConsumer")
	}

	var r0 jetstream.PushConsumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.PushConsumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.PushConsumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PushConsumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreateOrUpdatePushConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdatePushConsumer'
type Stream_CreateOrUpdatePushConsumer_Call struct {
	*mock.Call
}

// CreateOrUpdatePushConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *Stream_Expecter) CreateOrUpdatePushConsumer(ctx interface{}, stream interface{}, cfg interface{}) *Stream_CreateOrUpdatePushConsumer_Call {
	return &Stream_CreateOrUpdatePushConsumer_Call{Call: _e.mock.On("CreateOrUpdatePushConsumer", ctx, stream, cfg)}
}

func (_c *Stream_CreateOrUpdatePushConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *Stream_CreateOrUpdatePushConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *Stream_CreateOrUpdatePushConsumer_Call) Return(_a0 jetstream.PushConsumer, _a1 error) *Stream_CreateOrUpdatePushConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreateOrUpdatePushConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.PushConsumer, error)) *Stream_CreateOrUpdatePushConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateStream provides a mock function with given fields: ctx, cfg
func (_m *Stream) CreateOrUpdateStream(ctx context.Context, cfg jetstream.StreamConfig) (jetstream.Stream, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateStream")
	}

	var r0 jetstream.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) jetstream.Stream); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.StreamConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreateOrUpdateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateStream'
type Stream_CreateOrUpdateStream_Call struct {
	*mock.Call
}

// CreateOrUpdateStream is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.StreamConfig
func (_e *Stream_Expecter) CreateOrUpdateStream(ctx interface{}, cfg interface{}) *Stream_CreateOrUpdateStream_Call {
	return &Stream_CreateOrUpdateStream_Call{Call: _e.mock.On("CreateOrUpdateStream", ctx, cfg)}
}

func (_c *Stream_CreateOrUpdateStream_Call) Run(run func(ctx context.Context, cfg jetstream.StreamConfig)) *Stream_CreateOrUpdateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.StreamConfig))
	})
	return _c
}

func (_c *Stream_CreateOrUpdateStream_Call) Return(_a0 jetstream.Stream, _a1 error) *Stream_CreateOrUpdateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreateOrUpdateStream_Call) RunAndReturn(run func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)) *Stream_CreateOrUpdateStream_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePushConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *Stream) CreatePushConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.PushConsumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreatePushConsumer")
	}

	var r0 jetstream.PushConsumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.PushConsumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.PushConsumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PushConsumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreatePushConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePushConsumer'
type Stream_CreatePushConsumer_Call struct {
	*mock.Call
}

// CreatePushConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *Stream_Expecter) CreatePushConsumer(ctx interface{}, stream interface{}, cfg interface{}) *Stream_CreatePushConsumer_Call {
	return &Stream_CreatePushConsumer_Call{Call: _e.mock.On("CreatePushConsumer", ctx, stream, cfg)}
}

func (_c *Stream_CreatePushConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *Stream_CreatePushConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *Stream_CreatePushConsumer_Call) Return(_a0 jetstream.PushConsumer, _a1 error) *Stream_CreatePushConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreatePushConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.PushConsumer, error)) *Stream_CreatePushConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateStream provides a mock function with given fields: ctx, cfg
func (_m *Stream) CreateStream(ctx context.Context, cfg jetstream.StreamConfig) (jetstream.Stream, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateStream")
	}

	var r0 jetstream.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) jetstream.Stream); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.StreamConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_CreateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStream'
type Stream_CreateStream_Call struct {
	*mock.Call
}

// CreateStream is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.StreamConfig
func (_e *Stream_Expecter) CreateStream(ctx interface{}, cfg interface{}) *Stream_CreateStream_Call {
	return &Stream_CreateStream_Call{Call: _e.mock.On("CreateStream", ctx, cfg)}
}

func (_c *Stream_CreateStream_Call) Run(run func(ctx context.Context, cfg jetstream.StreamConfig)) *Stream_CreateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.StreamConfig))
	})
	return _c
}

func (_c *Stream_CreateStream_Call) Return(_a0 jetstream.Stream, _a1 error) *Stream_CreateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_CreateStream_Call) RunAndReturn(run func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)) *Stream_CreateStream_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConsumer provides a mock function with given fields: ctx, stream, consumer
func (_m *Stream) DeleteConsumer(ctx context.Context, stream string, consumer string) error {
	ret := _m.Called(ctx, stream, consumer)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConsumer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, stream, consumer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stream_DeleteConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConsumer'
type Stream_DeleteConsumer_Call struct {
	*mock.Call
}

// DeleteConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - consumer string
func (_e *Stream_Expecter) DeleteConsumer(ctx interface{}, stream interface{}, consumer interface{}) *Stream_DeleteConsumer_Call {
	return &Stream_DeleteConsumer_Call{Call: _e.mock.On("DeleteConsumer", ctx, stream, consumer)}
}

func (_c *Stream_DeleteConsumer_Call) Run(run func(ctx context.Context, stream string, consumer string)) *Stream_DeleteConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Stream_DeleteConsumer_Call) Return(_a0 error) *Stream_DeleteConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_DeleteConsumer_Call) RunAndReturn(run func(context.Context, string, string) error) *Stream_DeleteConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteKeyValue provides a mock function with given fields: ctx, bucket
func (_m *Stream) DeleteKeyValue(ctx context.Context, bucket string) error {
	ret := _m.Called(ctx, bucket)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKeyValue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, bucket)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stream_DeleteKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteKeyValue'
type Stream_DeleteKeyValue_Call struct {
	*mock.Call
}

// DeleteKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
func (_e *Stream_Expecter) DeleteKeyValue(ctx interface{}, bucket interface{}) *Stream_DeleteKeyValue_Call {
	return &Stream_DeleteKeyValue_Call{Call: _e.mock.On("DeleteKeyValue", ctx, bucket)}
}

func (_c *Stream_DeleteKeyValue_Call) Run(run func(ctx context.Context, bucket string)) *Stream_DeleteKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Stream_DeleteKeyValue_Call) Return(_a0 error) *Stream_DeleteKeyValue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_DeleteKeyValue_Call) RunAndReturn(run func(context.Context, string) error) *Stream_DeleteKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObjectStore provides a mock function with given fields: ctx, bucket
func (_m *Stream) DeleteObjectStore(ctx context.Context, bucket string) error {
	ret := _m.Called(ctx, bucket)

	if len(ret) == 0 {
		panic("no return value specified for DeleteObjectStore")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, bucket)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stream_DeleteObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjectStore'
type Stream_DeleteObjectStore_Call struct {
	*mock.Call
}

// DeleteObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
func (_e *Stream_Expecter) DeleteObjectStore(ctx interface{}, bucket interface{}) *Stream_DeleteObjectStore_Call {
	return &Stream_DeleteObjectStore_Call{Call: _e.mock.On("DeleteObjectStore", ctx, bucket)}
}

func (_c *Stream_DeleteObjectStore_Call) Run(run func(ctx context.Context, bucket string)) *Stream_DeleteObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Stream_DeleteObjectStore_Call) Return(_a0 error) *Stream_DeleteObjectStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_DeleteObjectStore_Call) RunAndReturn(run func(context.Context, string) error) *Stream_DeleteObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStream provides a mock function with given fields: ctx, stream
func (_m *Stream) DeleteStream(ctx context.Context, stream string) error {
	ret := _m.Called(ctx, stream)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStream")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, stream)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stream_DeleteStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStream'
type Stream_DeleteStream_Call struct {
	*mock.Call
}

// DeleteStream is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
func (_e *Stream_Expecter) DeleteStream(ctx interface{}, stream interface{}) *Stream_DeleteStream_Call {
	return &Stream_DeleteStream_Call{Call: _e.mock.On("DeleteStream", ctx, stream)}
}

func (_c *Stream_DeleteStream_Call) Run(run func(ctx context.Context, stream string)) *Stream_DeleteStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Stream_DeleteStream_Call) Return(_a0 error) *Stream_DeleteStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_DeleteStream_Call) RunAndReturn(run func(context.Context, string) error) *Stream_DeleteStream_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValue provides a mock function with given fields: ctx, bucket
func (_m *Stream) KeyValue(ctx context.Context, bucket string) (jetstream.KeyValue, error) {
	ret := _m.Called(ctx, bucket)

	if len(ret) == 0 {
		panic("no return value specified for KeyValue")
	}

	var r0 jetstream.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (jetstream.KeyValue, error)); ok {
		return rf(ctx, bucket)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) jetstream.KeyValue); ok {
		r0 = rf(ctx, bucket)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, bucket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_KeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValue'
type Stream_KeyValue_Call struct {
	*mock.Call
}

// KeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
func (_e *Stream_Expecter) KeyValue(ctx interface{}, bucket interface{}) *Stream_KeyValue_Call {
	return &Stream_KeyValue_Call{Call: _e.mock.On("KeyValue", ctx, bucket)}
}

func (_c *Stream_KeyValue_Call) Run(run func(ctx context.Context, bucket string)) *Stream_KeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Stream_KeyValue_Call) Return(_a0 jetstream.KeyValue, _a1 error) *Stream_KeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_KeyValue_Call) RunAndReturn(run func(context.Context, string) (jetstream.KeyValue, error)) *Stream_KeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValueStoreNames provides a mock function with given fields: ctx
func (_m *Stream) KeyValueStoreNames(ctx context.Context) jetstream.KeyValueNamesLister {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for KeyValueStoreNames")
	}

	var r0 jetstream.KeyValueNamesLister
	if rf, ok := ret.Get(0).(func(context.Context) jetstream.KeyValueNamesLister); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValueNamesLister)
		}
	}

	return r0
}

// Stream_KeyValueStoreNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValueStoreNames'
type Stream_KeyValueStoreNames_Call struct {
	*mock.Call
}

// KeyValueStoreNames is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Stream_Expecter) KeyValueStoreNames(ctx interface{}) *Stream_KeyValueStoreNames_Call {
	return &Stream_KeyValueStoreNames_Call{Call: _e.mock.On("KeyValueStoreNames", ctx)}
}

func (_c *Stream_KeyValueStoreNames_Call) Run(run func(ctx context.Context)) *Stream_KeyValueStoreNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Stream_KeyValueStoreNames_Call) Return(_a0 jetstream.KeyValueNamesLister) *Stream_KeyValueStoreNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_KeyValueStoreNames_Call) RunAndReturn(run func(context.Context) jetstream.KeyValueNamesLister) *Stream_KeyValueStoreNames_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValueStores provides a mock function with given fields: ctx
func (_m *Stream) KeyValueStores(ctx context.Context) jetstream.KeyValueLister {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for KeyValueStores")
	}

	var r0 jetstream.KeyValueLister
	if rf, ok := ret.Get(0).(func(context.Context) jetstream.KeyValueLister); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValueLister)
		}
	}

	return r0
}

// Stream_KeyValueStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValueStores'
type Stream_KeyValueStores_Call struct {
	*mock.Call
}

// KeyValueStores is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Stream_Expecter) KeyValueStores(ctx interface{}) *Stream_KeyValueStores_Call {
	return &Stream_KeyValueStores_Call{Call: _e.mock.On("KeyValueStores", ctx)}
}

func (_c *Stream_KeyValueStores_Call) Run(run func(ctx context.Context)) *Stream_KeyValueStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Stream_KeyValueStores_Call) Return(_a0 jetstream.KeyValueLister) *Stream_KeyValueStores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_KeyValueStores_Call) RunAndReturn(run func(context.Context) jetstream.KeyValueLister) *Stream_KeyValueStores_Call {
	_c.Call.Return(run)
	return _c
}

// ListStreams provides a mock function with given fields: _a0, _a1
func (_m *Stream) ListStreams(_a0 context.Context, _a1 ...jetstream.StreamListOpt) jetstream.StreamInfoLister {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStreams")
	}

	var r0 jetstream.StreamInfoLister
	if rf, ok := ret.Get(0).(func(context.Context, ...jetstream.StreamListOpt) jetstream.StreamInfoLister); ok {
		r0 = rf(_a0, _a1...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.StreamInfoLister)
		}
	}

	return r0
}

// Stream_ListStreams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListStreams'
type Stream_ListStreams_Call struct {
	*mock.Call
}

// ListStreams is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 ...jetstream.StreamListOpt
func (_e *Stream_Expecter) ListStreams(_a0 interface{}, _a1 ...interface{}) *Stream_ListStreams_Call {
	return &Stream_ListStreams_Call{Call: _e.mock.On("ListStreams",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *Stream_ListStreams_Call) Run(run func(_a0 context.Context, _a1 ...jetstream.StreamListOpt)) *Stream_ListStreams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.StreamListOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.StreamListOpt)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *Stream_ListStreams_Call) Return(_a0 jetstream.StreamInfoLister) *Stream_ListStreams_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_ListStreams_Call) RunAndReturn(run func(context.Context, ...jetstream.StreamListOpt) jetstream.StreamInfoLister) *Stream_ListStreams_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStore provides a mock function with given fields: ctx, bucket
func (_m *Stream) ObjectStore(ctx context.Context, bucket string) (jetstream.ObjectStore, error) {
	ret := _m.Called(ctx, bucket)

	if len(ret) == 0 {
		panic("no return value specified for ObjectStore")
	}

	var r0 jetstream.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (jetstream.ObjectStore, error)); ok {
		return rf(ctx, bucket)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) jetstream.ObjectStore); ok {
		r0 = rf(ctx, bucket)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, bucket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_ObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStore'
type Stream_ObjectStore_Call struct {
	*mock.Call
}

// ObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
func (_e *Stream_Expecter) ObjectStore(ctx interface{}, bucket interface{}) *Stream_ObjectStore_Call {
	return &Stream_ObjectStore_Call{Call: _e.mock.On("ObjectStore", ctx, bucket)}
}

func (_c *Stream_ObjectStore_Call) Run(run func(ctx context.Context, bucket string)) *Stream_ObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Stream_ObjectStore_Call) Return(_a0 jetstream.ObjectStore, _a1 error) *Stream_ObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_ObjectStore_Call) RunAndReturn(run func(context.Context, string) (jetstream.ObjectStore, error)) *Stream_ObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStoreNames provides a mock function with given fields: ctx
func (_m *Stream) ObjectStoreNames(ctx context.Context) jetstream.ObjectStoreNamesLister {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ObjectStoreNames")
	}

	var r0 jetstream.ObjectStoreNamesLister
	if rf, ok := ret.Get(0).(func(context.Context) jetstream.ObjectStoreNamesLister); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStoreNamesLister)
		}
	}

	return r0
}

// Stream_ObjectStoreNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStoreNames'
type Stream_ObjectStoreNames_Call struct {
	*mock.Call
}

// ObjectStoreNames is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Stream_Expecter) ObjectStoreNames(ctx interface{}) *Stream_ObjectStoreNames_Call {
	return &Stream_ObjectStoreNames_Call{Call: _e.mock.On("ObjectStoreNames", ctx)}
}

func (_c *Stream_ObjectStoreNames_Call) Run(run func(ctx context.Context)) *Stream_ObjectStoreNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Stream_ObjectStoreNames_Call) Return(_a0 jetstream.ObjectStoreNamesLister) *Stream_ObjectStoreNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_ObjectStoreNames_Call) RunAndReturn(run func(context.Context) jetstream.ObjectStoreNamesLister) *Stream_ObjectStoreNames_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStores provides a mock function with given fields: ctx
func (_m *Stream) ObjectStores(ctx context.Context) jetstream.ObjectStoresLister {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ObjectStores")
	}

	var r0 jetstream.ObjectStoresLister
	if rf, ok := ret.Get(0).(func(context.Context) jetstream.ObjectStoresLister); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStoresLister)
		}
	}

	return r0
}

// Stream_ObjectStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStores'
type Stream_ObjectStores_Call struct {
	*mock.Call
}

// ObjectStores is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Stream_Expecter) ObjectStores(ctx interface{}) *Stream_ObjectStores_Call {
	return &Stream_ObjectStores_Call{Call: _e.mock.On("ObjectStores", ctx)}
}

func (_c *Stream_ObjectStores_Call) Run(run func(ctx context.Context)) *Stream_ObjectStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Stream_ObjectStores_Call) Return(_a0 jetstream.ObjectStoresLister) *Stream_ObjectStores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_ObjectStores_Call) RunAndReturn(run func(context.Context) jetstream.ObjectStoresLister) *Stream_ObjectStores_Call {
	_c.Call.Return(run)
	return _c
}

// Options provides a mock function with no fields
func (_m *Stream) Options() jetstream.JetStreamOptions {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Options")
	}

	var r0 jetstream.JetStreamOptions
	if rf, ok := ret.Get(0).(func() jetstream.JetStreamOptions); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(jetstream.JetStreamOptions)
	}

	return r0
}

// Stream_Options_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Options'
type Stream_Options_Call struct {
	*mock.Call
}

// Options is a helper method to define mock.On call
func (_e *Stream_Expecter) Options() *Stream_Options_Call {
	return &Stream_Options_Call{Call: _e.mock.On("Options")}
}

func (_c *Stream_Options_Call) Run(run func()) *Stream_Options_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Stream_Options_Call) Return(_a0 jetstream.JetStreamOptions) *Stream_Options_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_Options_Call) RunAndReturn(run func() jetstream.JetStreamOptions) *Stream_Options_Call {
	_c.Call.Return(run)
	return _c
}

// OrderedConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *Stream) OrderedConsumer(ctx context.Context, stream string, cfg jetstream.OrderedConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for OrderedConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.OrderedConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.OrderedConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.OrderedConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_OrderedConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrderedConsumer'
type Stream_OrderedConsumer_Call struct {
	*mock.Call
}

// OrderedConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.OrderedConsumerConfig
func (_e *Stream_Expecter) OrderedConsumer(ctx interface{}, stream interface{}, cfg interface{}) *Stream_OrderedConsumer_Call {
	return &Stream_OrderedConsumer_Call{Call: _e.mock.On("OrderedConsumer", ctx, stream, cfg)}
}

func (_c *Stream_OrderedConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.OrderedConsumerConfig)) *Stream_OrderedConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.OrderedConsumerConfig))
	})
	return _c
}

func (_c *Stream_OrderedConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *Stream_OrderedConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_OrderedConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.OrderedConsumerConfig) (jetstream.Consumer, error)) *Stream_OrderedConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// PauseConsumer provides a mock function with given fields: ctx, stream, consumer, pauseUntil
func (_m *Stream) PauseConsumer(ctx context.Context, stream string, consumer string, pauseUntil time.Time) (*jetstream.ConsumerPauseResponse, error) {
	ret := _m.Called(ctx, stream, consumer, pauseUntil)

	if len(ret) == 0 {
		panic("no return value specified for PauseConsumer")
	}

	var r0 *jetstream.ConsumerPauseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Time) (*jetstream.ConsumerPauseResponse, error)); ok {
		return rf(ctx, stream, consumer, pauseUntil)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Time) *jetstream.ConsumerPauseResponse); ok {
		r0 = rf(ctx, stream, consumer, pauseUntil)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.ConsumerPauseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, time.Time) error); ok {
		r1 = rf(ctx, stream, consumer, pauseUntil)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_PauseConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PauseConsumer'
type Stream_PauseConsumer_Call struct {
	*mock.Call
}

// PauseConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - consumer string
//   - pauseUntil time.Time
func (_e *Stream_Expecter) PauseConsumer(ctx interface{}, stream interface{}, consumer interface{}, pauseUntil interface{}) *Stream_PauseConsumer_Call {
	return &Stream_PauseConsumer_Call{Call: _e.mock.On("PauseConsumer", ctx, stream, consumer, pauseUntil)}
}

func (_c *Stream_PauseConsumer_Call) Run(run func(ctx context.Context, stream string, consumer string, pauseUntil time.Time)) *Stream_PauseConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Time))
	})
	return _c
}

func (_c *Stream_PauseConsumer_Call) Return(_a0 *jetstream.ConsumerPauseResponse, _a1 error) *Stream_PauseConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_PauseConsumer_Call) RunAndReturn(run func(context.Context, string, string, time.Time) (*jetstream.ConsumerPauseResponse, error)) *Stream_PauseConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function with given fields: ctx, subject, payload, opts
func (_m *Stream) Publish(ctx context.Context, subject string, payload []byte, opts ...jetstream.PublishOpt) (*jetstream.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, subject, payload)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *jetstream.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, ...jetstream.PublishOpt) (*jetstream.PubAck, error)); ok {
		return rf(ctx, subject, payload, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, ...jetstream.PublishOpt) *jetstream.PubAck); ok {
		r0 = rf(ctx, subject, payload, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []byte, ...jetstream.PublishOpt) error); ok {
		r1 = rf(ctx, subject, payload, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type Stream_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - subject string
//   - payload []byte
//   - opts ...jetstream.PublishOpt
func (_e *Stream_Expecter) Publish(ctx interface{}, subject interface{}, payload interface{}, opts ...interface{}) *Stream_Publish_Call {
	return &Stream_Publish_Call{Call: _e.mock.On("Publish",
		append([]interface{}{ctx, subject, payload}, opts...)...)}
}

func (_c *Stream_Publish_Call) Run(run func(ctx context.Context, subject string, payload []byte, opts ...jetstream.PublishOpt)) *Stream_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *Stream_Publish_Call) Return(_a0 *jetstream.PubAck, _a1 error) *Stream_Publish_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_Publish_Call) RunAndReturn(run func(context.Context, string, []byte, ...jetstream.PublishOpt) (*jetstream.PubAck, error)) *Stream_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsync provides a mock function with given fields: subject, payload, opts
func (_m *Stream) PublishAsync(subject string, payload []byte, opts ...jetstream.PublishOpt) (jetstream.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subject, payload)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishAsync")
	}

	var r0 jetstream.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []byte, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)); ok {
		return rf(subject, payload, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, []byte, ...jetstream.PublishOpt) jetstream.PubAckFuture); ok {
		r0 = rf(subject, payload, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []byte, ...jetstream.PublishOpt) error); ok {
		r1 = rf(subject, payload, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_PublishAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsync'
type Stream_PublishAsync_Call struct {
	*mock.Call
}

// PublishAsync is a helper method to define mock.On call
//   - subject string
//   - payload []byte
//   - opts ...jetstream.PublishOpt
func (_e *Stream_Expecter) PublishAsync(subject interface{}, payload interface{}, opts ...interface{}) *Stream_PublishAsync_Call {
	return &Stream_PublishAsync_Call{Call: _e.mock.On("PublishAsync",
		append([]interface{}{subject, payload}, opts...)...)}
}

func (_c *Stream_PublishAsync_Call) Run(run func(subject string, payload []byte, opts ...jetstream.PublishOpt)) *Stream_PublishAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(string), args[1].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *Stream_PublishAsync_Call) Return(_a0 jetstream.PubAckFuture, _a1 error) *Stream_PublishAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_PublishAsync_Call) RunAndReturn(run func(string, []byte, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)) *Stream_PublishAsync_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncComplete provides a mock function with no fields
func (_m *Stream) PublishAsyncComplete() <-chan struct{} {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PublishAsyncComplete")
	}

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	return r0
}

// Stream_PublishAsyncComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncComplete'
type Stream_PublishAsyncComplete_Call struct {
	*mock.Call
}

// PublishAsyncComplete is a helper method to define mock.On call
func (_e *Stream_Expecter) PublishAsyncComplete() *Stream_PublishAsyncComplete_Call {
	return &Stream_PublishAsyncComplete_Call{Call: _e.mock.On("PublishAsyncComplete")}
}

func (_c *Stream_PublishAsyncComplete_Call) Run(run func()) *Stream_PublishAsyncComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Stream_PublishAsyncComplete_Call) Return(_a0 <-chan struct{}) *Stream_PublishAsyncComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_PublishAsyncComplete_Call) RunAndReturn(run func() <-chan struct{}) *Stream_PublishAsyncComplete_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncPending provides a mock function with no fields
func (_m *Stream) PublishAsyncPending() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PublishAsyncPending")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Stream_PublishAsyncPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncPending'
type Stream_PublishAsyncPending_Call struct {
	*mock.Call
}

// PublishAsyncPending is a helper method to define mock.On call
func (_e *Stream_Expecter) PublishAsyncPending() *Stream_PublishAsyncPending_Call {
	return &Stream_PublishAsyncPending_Call{Call: _e.mock.On("PublishAsyncPending")}
}

func (_c *Stream_PublishAsyncPending_Call) Run(run func()) *Stream_PublishAsyncPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Stream_PublishAsyncPending_Call) Return(_a0 int) *Stream_PublishAsyncPending_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_PublishAsyncPending_Call) RunAndReturn(run func() int) *Stream_PublishAsyncPending_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsg provides a mock function with given fields: ctx, msg, opts
func (_m *Stream) PublishMsg(ctx context.Context, msg *nats.Msg, opts ...jetstream.PublishOpt) (*jetstream.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, msg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishMsg")
	}

	var r0 *jetstream.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *nats.Msg, ...jetstream.PublishOpt) (*jetstream.PubAck, error)); ok {
		return rf(ctx, msg, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *nats.Msg, ...jetstream.PublishOpt) *jetstream.PubAck); ok {
		r0 = rf(ctx, msg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *nats.Msg, ...jetstream.PublishOpt) error); ok {
		r1 = rf(ctx, msg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_PublishMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsg'
type Stream_PublishMsg_Call struct {
	*mock.Call
}

// PublishMsg is a helper method to define mock.On call
//   - ctx context.Context
//   - msg *nats.Msg
//   - opts ...jetstream.PublishOpt
func (_e *Stream_Expecter) PublishMsg(ctx interface{}, msg interface{}, opts ...interface{}) *Stream_PublishMsg_Call {
	return &Stream_PublishMsg_Call{Call: _e.mock.On("PublishMsg",
		append([]interface{}{ctx, msg}, opts...)...)}
}

func (_c *Stream_PublishMsg_Call) Run(run func(ctx context.Context, msg *nats.Msg, opts ...jetstream.PublishOpt)) *Stream_PublishMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(context.Context), args[1].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *Stream_PublishMsg_Call) Return(_a0 *jetstream.PubAck, _a1 error) *Stream_PublishMsg_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_PublishMsg_Call) RunAndReturn(run func(context.Context, *nats.Msg, ...jetstream.PublishOpt) (*jetstream.PubAck, error)) *Stream_PublishMsg_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsgAsync provides a mock function with given fields: msg, opts
func (_m *Stream) PublishMsgAsync(msg *nats.Msg, opts ...jetstream.PublishOpt) (jetstream.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishMsgAsync")
	}

	var r0 jetstream.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)); ok {
		return rf(msg, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...jetstream.PublishOpt) jetstream.PubAckFuture); ok {
		r0 = rf(msg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.Msg, ...jetstream.PublishOpt) error); ok {
		r1 = rf(msg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_PublishMsgAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsgAsync'
type Stream_PublishMsgAsync_Call struct {
	*mock.Call
}

// PublishMsgAsync is a helper method to define mock.On call
//   - msg *nats.Msg
//   - opts ...jetstream.PublishOpt
func (_e *Stream_Expecter) PublishMsgAsync(msg interface{}, opts ...interface{}) *Stream_PublishMsgAsync_Call {
	return &Stream_PublishMsgAsync_Call{Call: _e.mock.On("PublishMsgAsync",
		append([]interface{}{msg}, opts...)...)}
}

func (_c *Stream_PublishMsgAsync_Call) Run(run func(msg *nats.Msg, opts ...jetstream.PublishOpt)) *Stream_PublishMsgAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *Stream_PublishMsgAsync_Call) Return(_a0 jetstream.PubAckFuture, _a1 error) *Stream_PublishMsgAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_PublishMsgAsync_Call) RunAndReturn(run func(*nats.Msg, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)) *Stream_PublishMsgAsync_Call {
	_c.Call.Return(run)
	return _c
}

// PushConsumer provides a mock function with given fields: ctx, stream, consumer
func (_m *Stream) PushConsumer(ctx context.Context, stream string, consumer string) (jetstream.PushConsumer, error) {
	ret := _m.Called(ctx, stream, consumer)

	if len(ret) == 0 {
		panic("no return value specified for PushConsumer")
	}

	var r0 jetstream.PushConsumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (jetstream.PushConsumer, error)); ok {
		return rf(ctx, stream, consumer)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) jetstream.PushConsumer); ok {
		r0 = rf(ctx, stream, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PushConsumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, stream, consumer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_PushConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PushConsumer'
type Stream_PushConsumer_Call struct {
	*mock.Call
}

// PushConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - consumer string
func (_e *Stream_Expecter) PushConsumer(ctx interface{}, stream interface{}, consumer interface{}) *Stream_PushConsumer_Call {
	return &Stream_PushConsumer_Call{Call: _e.mock.On("PushConsumer", ctx, stream, consumer)}
}

func (_c *Stream_PushConsumer_Call) Run(run func(ctx context.Context, stream string, consumer string)) *Stream_PushConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Stream_PushConsumer_Call) Return(_a0 jetstream.PushConsumer, _a1 error) *Stream_PushConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_PushConsumer_Call) RunAndReturn(run func(context.Context, string, string) (jetstream.PushConsumer, error)) *Stream_PushConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// ResumeConsumer provides a mock function with given fields: ctx, stream, consumer
func (_m *Stream) ResumeConsumer(ctx context.Context, stream string, consumer string) (*jetstream.ConsumerPauseResponse, error) {
	ret := _m.Called(ctx, stream, consumer)

	if len(ret) == 0 {
		panic("no return value specified for ResumeConsumer")
	}

	var r0 *jetstream.ConsumerPauseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*jetstream.ConsumerPauseResponse, error)); ok {
		return rf(ctx, stream, consumer)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *jetstream.ConsumerPauseResponse); ok {
		r0 = rf(ctx, stream, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.ConsumerPauseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, stream, consumer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_ResumeConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResumeConsumer'
type Stream_ResumeConsumer_Call struct {
	*mock.Call
}

// ResumeConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - consumer string
func (_e *Stream_Expecter) ResumeConsumer(ctx interface{}, stream interface{}, consumer interface{}) *Stream_ResumeConsumer_Call {
	return &Stream_ResumeConsumer_Call{Call: _e.mock.On("ResumeConsumer", ctx, stream, consumer)}
}

func (_c *Stream_ResumeConsumer_Call) Run(run func(ctx context.Context, stream string, consumer string)) *Stream_ResumeConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *Stream_ResumeConsumer_Call) Return(_a0 *jetstream.ConsumerPauseResponse, _a1 error) *Stream_ResumeConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_ResumeConsumer_Call) RunAndReturn(run func(context.Context, string, string) (*jetstream.ConsumerPauseResponse, error)) *Stream_ResumeConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// Stream provides a mock function with given fields: ctx, stream
func (_m *Stream) Stream(ctx context.Context, stream string) (jetstream.Stream, error) {
	ret := _m.Called(ctx, stream)

	if len(ret) == 0 {
		panic("no return value specified for Stream")
	}

	var r0 jetstream.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (jetstream.Stream, error)); ok {
		return rf(ctx, stream)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) jetstream.Stream); ok {
		r0 = rf(ctx, stream)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, stream)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_Stream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stream'
type Stream_Stream_Call struct {
	*mock.Call
}

// Stream is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
func (_e *Stream_Expecter) Stream(ctx interface{}, stream interface{}) *Stream_Stream_Call {
	return &Stream_Stream_Call{Call: _e.mock.On("Stream", ctx, stream)}
}

func (_c *Stream_Stream_Call) Run(run func(ctx context.Context, stream string)) *Stream_Stream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Stream_Stream_Call) Return(_a0 jetstream.Stream, _a1 error) *Stream_Stream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_Stream_Call) RunAndReturn(run func(context.Context, string) (jetstream.Stream, error)) *Stream_Stream_Call {
	_c.Call.Return(run)
	return _c
}

// StreamNameBySubject provides a mock function with given fields: ctx, subject
func (_m *Stream) StreamNameBySubject(ctx context.Context, subject string) (string, error) {
	ret := _m.Called(ctx, subject)

	if len(ret) == 0 {
		panic("no return value specified for StreamNameBySubject")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, subject)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, subject)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, subject)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_StreamNameBySubject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamNameBySubject'
type Stream_StreamNameBySubject_Call struct {
	*mock.Call
}

// StreamNameBySubject is a helper method to define mock.On call
//   - ctx context.Context
//   - subject string
func (_e *Stream_Expecter) StreamNameBySubject(ctx interface{}, subject interface{}) *Stream_StreamNameBySubject_Call {
	return &Stream_StreamNameBySubject_Call{Call: _e.mock.On("StreamNameBySubject", ctx, subject)}
}

func (_c *Stream_StreamNameBySubject_Call) Run(run func(ctx context.Context, subject string)) *Stream_StreamNameBySubject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Stream_StreamNameBySubject_Call) Return(_a0 string, _a1 error) *Stream_StreamNameBySubject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_StreamNameBySubject_Call) RunAndReturn(run func(context.Context, string) (string, error)) *Stream_StreamNameBySubject_Call {
	_c.Call.Return(run)
	return _c
}

// StreamNames provides a mock function with given fields: _a0, _a1
func (_m *Stream) StreamNames(_a0 context.Context, _a1 ...jetstream.StreamListOpt) jetstream.StreamNameLister {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StreamNames")
	}

	var r0 jetstream.StreamNameLister
	if rf, ok := ret.Get(0).(func(context.Context, ...jetstream.StreamListOpt) jetstream.StreamNameLister); ok {
		r0 = rf(_a0, _a1...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.StreamNameLister)
		}
	}

	return r0
}

// Stream_StreamNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamNames'
type Stream_StreamNames_Call struct {
	*mock.Call
}

// StreamNames is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 ...jetstream.StreamListOpt
func (_e *Stream_Expecter) StreamNames(_a0 interface{}, _a1 ...interface{}) *Stream_StreamNames_Call {
	return &Stream_StreamNames_Call{Call: _e.mock.On("StreamNames",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *Stream_StreamNames_Call) Run(run func(_a0 context.Context, _a1 ...jetstream.StreamListOpt)) *Stream_StreamNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.StreamListOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.StreamListOpt)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *Stream_StreamNames_Call) Return(_a0 jetstream.StreamNameLister) *Stream_StreamNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Stream_StreamNames_Call) RunAndReturn(run func(context.Context, ...jetstream.StreamListOpt) jetstream.StreamNameLister) *Stream_StreamNames_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *Stream) UpdateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_UpdateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateConsumer'
type Stream_UpdateConsumer_Call struct {
	*mock.Call
}

// UpdateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *Stream_Expecter) UpdateConsumer(ctx interface{}, stream interface{}, cfg interface{}) *Stream_UpdateConsumer_Call {
	return &Stream_UpdateConsumer_Call{Call: _e.mock.On("UpdateConsumer", ctx, stream, cfg)}
}

func (_c *Stream_UpdateConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *Stream_UpdateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *Stream_UpdateConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *Stream_UpdateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_UpdateConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)) *Stream_UpdateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateKeyValue provides a mock function with given fields: ctx, cfg
func (_m *Stream) UpdateKeyValue(ctx context.Context, cfg jetstream.KeyValueConfig) (jetstream.KeyValue, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKeyValue")
	}

	var r0 jetstream.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) jetstream.KeyValue); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.KeyValueConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_UpdateKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateKeyValue'
type Stream_UpdateKeyValue_Call struct {
	*mock.Call
}

// UpdateKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.KeyValueConfig
func (_e *Stream_Expecter) UpdateKeyValue(ctx interface{}, cfg interface{}) *Stream_UpdateKeyValue_Call {
	return &Stream_UpdateKeyValue_Call{Call: _e.mock.On("UpdateKeyValue", ctx, cfg)}
}

func (_c *Stream_UpdateKeyValue_Call) Run(run func(ctx context.Context, cfg jetstream.KeyValueConfig)) *Stream_UpdateKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.KeyValueConfig))
	})
	return _c
}

func (_c *Stream_UpdateKeyValue_Call) Return(_a0 jetstream.KeyValue, _a1 error) *Stream_UpdateKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_UpdateKeyValue_Call) RunAndReturn(run func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)) *Stream_UpdateKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateObjectStore provides a mock function with given fields: ctx, cfg
func (_m *Stream) UpdateObjectStore(ctx context.Context, cfg jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateObjectStore")
	}

	var r0 jetstream.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) jetstream.ObjectStore); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.ObjectStoreConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_UpdateObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateObjectStore'
type Stream_UpdateObjectStore_Call struct {
	*mock.Call
}

// UpdateObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.ObjectStoreConfig
func (_e *Stream_Expecter) UpdateObjectStore(ctx interface{}, cfg interface{}) *Stream_UpdateObjectStore_Call {
	return &Stream_UpdateObjectStore_Call{Call: _e.mock.On("UpdateObjectStore", ctx, cfg)}
}

func (_c *Stream_UpdateObjectStore_Call) Run(run func(ctx context.Context, cfg jetstream.ObjectStoreConfig)) *Stream_UpdateObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.ObjectStoreConfig))
	})
	return _c
}

func (_c *Stream_UpdateObjectStore_Call) Return(_a0 jetstream.ObjectStore, _a1 error) *Stream_UpdateObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_UpdateObjectStore_Call) RunAndReturn(run func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)) *Stream_UpdateObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePushConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *Stream) UpdatePushConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.PushConsumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePushConsumer")
	}

	var r0 jetstream.PushConsumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.PushConsumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.PushConsumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PushConsumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_UpdatePushConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePushConsumer'
type Stream_UpdatePushConsumer_Call struct {
	*mock.Call
}

// UpdatePushConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *Stream_Expecter) UpdatePushConsumer(ctx interface{}, stream interface{}, cfg interface{}) *Stream_UpdatePushConsumer_Call {
	return &Stream_UpdatePushConsumer_Call{Call: _e.mock.On("UpdatePushConsumer", ctx, stream, cfg)}
}

func (_c *Stream_UpdatePushConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *Stream_UpdatePushConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *Stream_UpdatePushConsumer_Call) Return(_a0 jetstream.PushConsumer, _a1 error) *Stream_UpdatePushConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_UpdatePushConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.PushConsumer, error)) *Stream_UpdatePushConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStream provides a mock function with given fields: ctx, cfg
func (_m *Stream) UpdateStream(ctx context.Context, cfg jetstream.StreamConfig) (jetstream.Stream, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStream")
	}

	var r0 jetstream.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) jetstream.Stream); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.StreamConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stream_UpdateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStream'
type Stream_UpdateStream_Call struct {
	*mock.Call
}

// UpdateStream is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.StreamConfig
func (_e *Stream_Expecter) UpdateStream(ctx interface{}, cfg interface{}) *Stream_UpdateStream_Call {
	return &Stream_UpdateStream_Call{Call: _e.mock.On("UpdateStream", ctx, cfg)}
}

func (_c *Stream_UpdateStream_Call) Run(run func(ctx context.Context, cfg jetstream.StreamConfig)) *Stream_UpdateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.StreamConfig))
	})
	return _c
}

func (_c *Stream_UpdateStream_Call) Return(_a0 jetstream.Stream, _a1 error) *Stream_UpdateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Stream_UpdateStream_Call) RunAndReturn(run func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)) *Stream_UpdateStream_Call {
	_c.Call.Return(run)
	return _c
}

// NewStream creates a new instance of Stream. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStream(t interface {
	mock.TestingT
	Cleanup(func())
}) *Stream {
	mock := &Stream{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
